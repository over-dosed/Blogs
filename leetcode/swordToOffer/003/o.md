# 剑指offer 003 二进制1的个数

![20220107182450](https://picture-1308922338.cos.ap-guangzhou.myqcloud.com/note/20220107182450.png)

这道题虽然是简单难度，但题解思路非常之精妙让我忍不住写个blog记录下来

愚钝如我，只能想到先将数用二进制表达，再一一计算其中1的数量。而其中蕴含的规律，即—— **不同数之间的二进制1的个数之间联系**

愚钝如我自然也是想不出这样的解决方法：
| 原数 | 二进制 | 1的个数 |
| ---- | ------ | ------- |
| 0    | 0      | 0       |
| 1    | 1      | 1       |
| 2    | 10     | 1       |
| 3    | 11     | 2       |
| 4    | 100    | 1       |
| 5    | 101    | 2       |
| 6    | 110    | 2       |
| 7    | 111    | 3       |
| 8    | 1000   | 1       |
| 9    | 1001   | 2       |
| 10   | 1010   | 2       |
| 11   | 1011   | 3       |
| 12   | 1100   | 2       |
| 13   | 1101   | 3       |
| 14   | 1110   | 3       |
| 15   | 1111   | 4       |
| 16   | 10000  | 1       |
| 17   | 10001  | 2       |
| 18   | 10010  | 2       |
| 19   | 10011  | 3       |
| 20   | 10100  | 2       |
| 21   | 10101  | 3       |
| 22   | 10110  | 3       |
| 23   | 10111  | 4       |

我们知道 ： 一个二进制数，左移一位得到的数，与原数所含1的个数相同： 101 ：2 ———— 1010 ：2

对应地：2a == a （包含1的个数） => a == a/2 => a == a>>1

上述是**偶数**情况，那**奇数**怎么办呢？

我们知道奇数的二进制最后一位是1，而右移一位，会得到：
a = a>>1 + 1

故得到下述代码，时间复杂度 O(n) ：

~~~ C
class Solution {
    public:
        vector<int> countBits(int n) 
        {   
            vector<int> result = vector<int>(n+1,0);
            for(int i = 1; i<= n ; i = i+1)
            {
                result[i] = result[i>>1] + (i%2); 
            }
            return result;
        }
};
~~~

代码主体仅仅6行而已。
![20220108195847](https://picture-1308922338.cos.ap-guangzhou.myqcloud.com/note/20220108195847.png)
