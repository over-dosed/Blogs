# python 全局变量的修改，函数传参类型

在调试python程序时，发现将全局变量传入函数中，函数内对该变量产生的修改不会作用到真实值上，例如：

~~~python
best_loss = 3.7          # 全局变量

def process(i,*best_loss):   # 传入全局变量的函数
    i = i + i
    if i > best_loss:
        best_loss = i        # 对全局变量的修改


for i in range(10):
    process(i,best_loss)

print(best_loss)            # 输出全局变量值
~~~

上述代码输出结果为： 3.7 . 即： **全局变量best_loss的值在经过函数的改变后没有影响**

查询网上教程才发现：

## Python 的参数传递

python没有c++的三种传递：

1. **值传递**，顾名思义，只传值不传地址。在函数体内另开内存储变量，不会改变原来的值。
2. **地址传递**，传入的是原来变量的地址，也就是会改变原来的值，共享一个地址。
3. **引用传递**。和地址传递差不多，都会改变原来的值。不同的是传引用相当于给传入的参数取了一个别名，使用别名进行操作，其实处理的是同一个东西。

java中则是两种传递：

1. **值传递**。对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量。
2. **引用传递**。一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。

一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递。

python则只有一种传递方式，根据传入的变量进行判断。如果传入的常数、元组等不可变的参数，那么对该参数的修改不会反映到原参数上；反之，如果传入的是list、array这种可变参数，那么对其修改就会反映到原参数上。

## python 的全局变量

涉及到python的作用域：我把别人的小结贴出来[全文](https://www.cnblogs.com/tootooman/p/8990633.html)：

（1）变量查找顺序：LEGB，局部作用域>外层作用域>当前模块中的全局>python内置作用域；

（2）只有模块、类、及函数才能引入新作用域；

（3）对于一个变量，内部作用域先声明就会覆盖外部变量，不声明直接使用，就会使用外部作用域的变量；

（4）内部作用域要修改外部作用域变量的值时，全局变量要使用global关键字，嵌套作用域变量要使用nonlocal关键字。nonlocal是python3新增的关键字，有了这个关键字，就能完美的实现闭包了。

如果不加global关键字的问题在于：函数内部会新建一个变量执行操作，但是因为内部的作用域查找顺序高于全局的作用域，所以会导致修改失败。
如果要在一个函数内部修改全局变量，只需要在该函数内部的变量名称前加一个global即可

~~~python
global best_loss

best_loss = 2
~~~
